<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>API Test</title>
    <style>
      body {
        font-family: monospace;
        background: #f9f9f9;
        padding: 20px;
      }

      .panel-container {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
      }

      .panel {
        flex: 1;
        border: 2px solid #0078d7;
        border-radius: 8px;
        padding: 15px;
        background: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .panel-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #0078d7;
      }

      button {
        margin-right: 10px;
        padding: 8px 14px;
        border: none;
        border-radius: 4px;
        background-color: #0078d7;
        color: white;
        cursor: pointer;
      }

      button.stop {
        background-color: #d9534f;
      }

      button:disabled {
        background-color: #999;
        cursor: not-allowed;
      }

      #output {
        white-space: pre-wrap;
        background: #fff;
        padding: 10px;
        border: 1px solid #ccc;
        height: 65vh;
        overflow-y: auto;
        margin-top: 15px;
      }

      #stats {
        margin-top: 10px;
        font-weight: bold;
        color: #333;
      }
    </style>
  </head>
  <body>
    <h2>API Test</h2>

    <div class="panel-container">
      <!-- Panel 1: Fetch Operations -->
      <div class="panel">
        <div class="panel-title">üîç Fetch</div>
        <button id="getAll">Get All</button>
        <button id="stream">Start Stream</button>
        <button id="stopStream" class="stop" disabled>Stop Stream</button>
      </div>

      <!-- Panel 2: Downloads -->
      <div class="panel">
        <div class="panel-title">üì• Downloads</div>
        <button id="download">Download</button>
        <button id="downloadStream">Download Stream</button>
      </div>
    </div>

    <div id="stats">
      Records received: <span id="count">0</span> | API time:
      <span id="apiTimer">0.0</span>s | Render time:
      <span id="renderTimer">0.0</span>s
    </div>

    <div id="output"></div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const output = document.getElementById("output");
        const countSpan = document.getElementById("count");
        const apiTimerSpan = document.getElementById("apiTimer");
        const renderTimerSpan = document.getElementById("renderTimer");
        const getAllBtn = document.getElementById("getAll");
        const streamBtn = document.getElementById("stream");
        const stopStreamBtn = document.getElementById("stopStream");
        const downloadBtn = document.getElementById("download");
        const downloadStreamBtn = document.getElementById("downloadStream");

        const apiBase = "https://localhost:55961/api/people";
        let controller = null;
        let isStreaming = false;
        let renderStarted = false;

        function resetOutput(label) {
          output.textContent = `${label} started...\n\n`;
          countSpan.textContent = "0";
          apiTimerSpan.textContent = "0.0";
          renderTimerSpan.textContent = "0.0";
        }

        function startTimer(ref, span) {
          const start = Date.now();
          const interval = setInterval(() => {
            const elapsed = (Date.now() - start) / 1000;
            span.textContent = elapsed.toFixed(1);
          }, 200);
          return { start, interval };
        }

        function stopTimer(intervalObj, span) {
          if (intervalObj) clearInterval(intervalObj.interval);
          if (span) {
            const elapsed = (Date.now() - intervalObj.start) / 1000;
            span.textContent = elapsed.toFixed(1);
          }
        }

        function disableAll(disabled = true) {
          getAllBtn.disabled = disabled;
          streamBtn.disabled = disabled;
          downloadBtn.disabled = disabled;
          downloadStreamBtn.disabled = disabled;
        }

        // GetAll
        getAllBtn.addEventListener("click", async () => {
          resetOutput("GetAll");
          disableAll(true);
          const apiTimer = startTimer(null, apiTimerSpan);
          let renderTimer = null;
          try {
            const response = await fetch(apiBase);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            renderTimer = startTimer(null, renderTimerSpan);
            countSpan.textContent = data.length;
            output.textContent += JSON.stringify(data, null, 2);

            // ‚úÖ Wait for full render cycle
            await new Promise(requestAnimationFrame);
            stopTimer(renderTimer, renderTimerSpan);
          } catch (err) {
            output.textContent += `\n‚ùå Error: ${err.message}`;
          } finally {
            disableAll(false);
            stopTimer(apiTimer, apiTimerSpan);
          }
        });

        // Stream
        streamBtn.addEventListener("click", async () => {
          resetOutput("Streaming");
          disableAll(true);
          stopStreamBtn.disabled = false;
          controller = new AbortController();
          isStreaming = true;
          renderStarted = false;
          const apiTimer = startTimer(null, apiTimerSpan);

          try {
            const response = await fetch(`${apiBase}/stream`, {
              signal: controller.signal,
            });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            if (!response.body) {
              output.textContent = "Streaming not supported.";
              return;
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder("utf-8");
            let buffer = "";
            let recordCount = 0;
            let renderTimer = null;

            async function updateUI(obj) {
              if (!isStreaming) return;
              if (!renderStarted) {
                renderStarted = true;
                renderTimer = startTimer(null, renderTimerSpan);
              }

              recordCount++;
              countSpan.textContent = recordCount;
              output.textContent += JSON.stringify(obj) + "\n";
              if (recordCount % 10 === 0)
                await new Promise((r) => setTimeout(r, 0));
              output.scrollTop = output.scrollHeight;
            }

            while (isStreaming) {
              const { done, value } = await reader.read();
              if (done || !isStreaming) break;
              buffer += decoder.decode(value, { stream: true });
              buffer = buffer.replace(/^\s*\[/, "");
              buffer = buffer.replace(/\]\s*$/, "");
              let boundary = buffer.indexOf("},{");
              while (boundary !== -1 && isStreaming) {
                const jsonText = buffer.substring(0, boundary + 1);
                buffer = buffer.substring(boundary + 2);
                boundary = buffer.indexOf("},{");
                try {
                  const obj = JSON.parse(jsonText);
                  await updateUI(obj);
                } catch {}
              }
            }

            if (isStreaming) {
              try {
                const last = buffer.trim();
                if (last && last !== "]") {
                  const obj = JSON.parse(last);
                  await updateUI(obj);
                }
              } catch {}
              output.textContent += `\n‚úÖ Streaming complete.`;
            }

            if (renderStarted && renderTimer)
              stopTimer(renderTimer, renderTimerSpan);
          } catch (err) {
            if (err.name === "AbortError") {
              output.textContent += `\n‚õî Stream stopped by user.`;
            } else {
              output.textContent += `\n‚ùå Error: ${err.message}`;
            }
          } finally {
            isStreaming = false;
            disableAll(false);
            stopStreamBtn.disabled = true;
            stopTimer(apiTimer, apiTimerSpan);
          }
        });

        // Stop Stream
        stopStreamBtn.addEventListener("click", () => {
          if (controller) controller.abort();
          isStreaming = false;
          stopStreamBtn.disabled = true;
          output.textContent += `\nüõë Stream stopping...`;
        });

        // Download
        downloadBtn.addEventListener("click", async () => {
          resetOutput("Download");
          disableAll(true);
          const apiTimer = startTimer(null, apiTimerSpan);
          let renderTimer = null;
          try {
            const response = await fetch(`${apiBase}/download`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();

            renderTimer = startTimer(null, renderTimerSpan);
            const blob = new Blob([JSON.stringify(data, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "all-records.json";
            a.click();
            URL.revokeObjectURL(url);

            countSpan.textContent = data.length;
            output.textContent += `‚úÖ File downloaded (${data.length} records).`;

            // ‚úÖ Wait until browser finishes paint
            await new Promise(requestAnimationFrame);
            stopTimer(renderTimer, renderTimerSpan);
          } catch (err) {
            output.textContent += `\n‚ùå Error: ${err.message}`;
          } finally {
            disableAll(false);
            stopTimer(apiTimer, apiTimerSpan);
          }
        });

        // Download Stream
        downloadStreamBtn.addEventListener("click", async () => {
          resetOutput("Download Stream");
          disableAll(true);
          const apiTimer = startTimer(null, apiTimerSpan);
          let renderTimer = null;
          try {
            const response = await fetch(`${apiBase}/download-stream`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            renderTimer = startTimer(null, renderTimerSpan);

            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "all-records-stream.json";
            a.click();
            URL.revokeObjectURL(url);

            output.textContent += `‚úÖ Stream file downloaded successfully.\n`;

            // ‚úÖ Wait for render to complete
            await new Promise(requestAnimationFrame);
            stopTimer(renderTimer, renderTimerSpan);
          } catch (err) {
            output.textContent += `\n‚ùå Error: ${err.message}`;
          } finally {
            disableAll(false);
            stopTimer(apiTimer, apiTimerSpan);
          }
        });
      });
    </script>
  </body>
</html>
